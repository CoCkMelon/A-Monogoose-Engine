#!/usr/bin/env python3
import os, sys, json
try:
    import yaml
except ImportError:
    print("PyYAML not installed. Install with: pip install pyyaml", file=sys.stderr)
    sys.exit(1)

HEADER = """
// Auto-generated by tools/dialogue_yaml_to_c.py
// Do not edit by hand.
#ifndef AME_DIALOGUE_GENERATED_H
#define AME_DIALOGUE_GENERATED_H
#include <stddef.h>
#include "ame_dialogue.h"
#define AME_HAVE_GENERATED_DIALOGUES 1
extern const AmeDialogueScene *ame__generated_scenes[];
extern const size_t ame__generated_scenes_count;
#endif
""".strip() + "\n"

C_SOURCE_PREAMBLE = """
// Auto-generated by tools/dialogue_yaml_to_c.py
// Do not edit by hand.
#include "ame_dialogue.h"
#include <stddef.h>

""".strip() + "\n"


def sanitize_c_ident(s: str) -> str:
    out = []
    for ch in s:
        if ch.isalnum() or ch == '_':
            out.append(ch)
        else:
            out.append('_')
    ident = ''.join(out)
    if ident and ident[0].isdigit():
        ident = '_' + ident
    return ident


def emit_scene(name: str, scene: dict, out_lines: list):
    base = sanitize_c_ident(name)
    option_arrays = []
    # Pre-emit options arrays
    lines = scene.get('lines', []) or []
    for i, line in enumerate(lines):
        opts = line.get('options') or []
        if opts:
            arr_name = f"{base}_opts_{i}"
            option_arrays.append((arr_name, opts))
    for arr_name, opts in option_arrays:
        out_lines.append(f"static const AmeDialogueOption {arr_name}[] = {{")
        for opt in opts:
            choice = (opt.get('choice') or '').replace('"', '\\"')
            nxt = (opt.get('next') or '').replace('"', '\\"')
            out_lines.append(f"    {{\"{choice}\", \"{nxt}\"}},")
        out_lines.append("};\n")

    # Emit lines array
    lines_var = f"{base}_lines"
    out_lines.append(f"static const AmeDialogueLine {lines_var}[] = {{")
    for i, line in enumerate(lines):
        def f(key):
            val = line.get(key)
            if val is None:
                return 'NULL'
            s = str(val).replace('"', '\\"')
            return f'"{s}"' if s else 'NULL'
        opts = line.get('options') or []
        if opts:
            arr_name = f"{base}_opts_{i}"
            opt_ptr = arr_name
            opt_cnt = str(len(opts))
        else:
            opt_ptr = 'NULL'
            opt_cnt = '0'
        out_lines.append(
            "    { %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s }," % (
                f('id'), f('speaker'), f('text'), f('sprite'), f('sound'), f('animation'),
                f('cutscene'), f('trigger'), f('quest_id'), f('next_scene'), opt_ptr, opt_cnt
            )
        )
    out_lines.append("};\n")

    # Emit scene object
    scene_var = f"scene_{base}"
    scene_name_c = name.replace('"', '\\"')
    out_lines.append(f"static const AmeDialogueScene {scene_var} = {{ .scene=\"{scene_name_c}\", .lines={lines_var}, .line_count=sizeof({lines_var})/sizeof({lines_var}[0]) }};\n")

    return scene_var


def main():
    if len(sys.argv) < 3:
        print("Usage: tools/dialogue_yaml_to_c.py <input_dir> <output_dir>", file=sys.stderr)
        sys.exit(2)
    in_dir = sys.argv[1]
    out_dir = sys.argv[2]
    if not os.path.isdir(in_dir):
        print(f"Input dir not found: {in_dir}", file=sys.stderr)
        sys.exit(3)
    os.makedirs(out_dir, exist_ok=True)
    # Collect YAML files
    yamls = []
    for root, dirs, files in os.walk(in_dir):
        for f in files:
            if f.lower().endswith(('.yaml', '.yml')):
                yamls.append(os.path.join(root, f))
    if not yamls:
        print("No YAML files found.", file=sys.stderr)
    # Generate header and c source
    header_path = os.path.join(os.path.dirname(out_dir), 'include', 'ame_dialogue_generated.h')
    src_path = os.path.join(out_dir, 'embedded_dialogues_gen.c')

    with open(header_path, 'w') as hf:
        hf.write(HEADER)

    lines = [C_SOURCE_PREAMBLE]
    scene_ptrs = []
    for yf in yamls:
        with open(yf, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f) or {}
        # Accept either a single scene or a mapping of name->scene
        if 'title' in data or 'scene' in data or 'lines' in data:
            name = data.get('scene') or os.path.splitext(os.path.basename(yf))[0]
            scene_var = emit_scene(name, data, lines)
            scene_ptrs.append(scene_var)
        else:
            for name, scene in (data.items() if isinstance(data, dict) else []):
                scene_var = emit_scene(name, scene, lines)
                scene_ptrs.append(scene_var)
    # Registry
    lines.append("const AmeDialogueScene *ame__generated_scenes[] = {")
    for sv in scene_ptrs:
        lines.append(f"    &{sv},")
    lines.append("};\n")
    lines.append(f"const size_t ame__generated_scenes_count = sizeof(ame__generated_scenes)/sizeof(ame__generated_scenes[0]);\n")

    with open(src_path, 'w') as sf:
        sf.write('\n'.join(lines))

    print(f"Wrote {header_path}\nWrote {src_path}")

if __name__ == '__main__':
    main()
